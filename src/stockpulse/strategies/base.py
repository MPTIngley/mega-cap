"""Base strategy class and signal definitions."""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime, date
from enum import Enum
from typing import Any

import pandas as pd
import numpy as np


class SignalDirection(Enum):
    """Direction of a trading signal."""
    BUY = "BUY"
    SELL = "SELL"


@dataclass
class Signal:
    """A trading signal generated by a strategy."""
    ticker: str
    strategy: str
    direction: SignalDirection
    confidence: float  # 0-100
    entry_price: float
    target_price: float
    stop_price: float
    timestamp: datetime = field(default_factory=datetime.now)
    notes: str = ""

    def to_dict(self) -> dict[str, Any]:
        """Convert signal to dictionary."""
        return {
            "ticker": self.ticker,
            "strategy": self.strategy,
            "direction": self.direction.value,
            "confidence": self.confidence,
            "entry_price": self.entry_price,
            "target_price": self.target_price,
            "stop_price": self.stop_price,
            "timestamp": self.timestamp,
            "notes": self.notes
        }

    @property
    def risk_reward_ratio(self) -> float:
        """Calculate risk/reward ratio."""
        if self.direction == SignalDirection.BUY:
            reward = self.target_price - self.entry_price
            risk = self.entry_price - self.stop_price
        else:
            reward = self.entry_price - self.target_price
            risk = self.stop_price - self.entry_price

        if risk <= 0:
            return 0
        return reward / risk

    @property
    def expected_return_pct(self) -> float:
        """Expected return percentage if target hit."""
        if self.direction == SignalDirection.BUY:
            return ((self.target_price - self.entry_price) / self.entry_price) * 100
        return ((self.entry_price - self.target_price) / self.entry_price) * 100

    @property
    def max_loss_pct(self) -> float:
        """Maximum loss percentage if stop hit."""
        if self.direction == SignalDirection.BUY:
            return ((self.entry_price - self.stop_price) / self.entry_price) * 100
        return ((self.stop_price - self.entry_price) / self.entry_price) * 100


class BaseStrategy(ABC):
    """
    Abstract base class for trading strategies.

    All strategies must implement:
    - name: Strategy identifier
    - generate_signals: Main signal generation logic
    - calculate_indicators: Technical indicator calculation
    """

    def __init__(self, config: dict[str, Any]):
        """
        Initialize strategy with configuration.

        Args:
            config: Strategy-specific configuration dictionary
        """
        self.config = config
        self.enabled = config.get("enabled", True)
        self.min_confidence = config.get("min_confidence", 60)
        self.stop_loss_pct = config.get("stop_loss_pct", 5.0)
        self.take_profit_pct = config.get("take_profit_pct", 10.0)
        self.hold_days_min = config.get("hold_days_min", 2)
        self.hold_days_max = config.get("hold_days_max", 20)

    @property
    @abstractmethod
    def name(self) -> str:
        """Strategy name/identifier."""
        pass

    @abstractmethod
    def calculate_indicators(self, df: pd.DataFrame) -> pd.DataFrame:
        """
        Calculate technical indicators needed by this strategy.

        Args:
            df: DataFrame with OHLCV data (columns: open, high, low, close, volume)

        Returns:
            DataFrame with added indicator columns
        """
        pass

    @abstractmethod
    def generate_signals(
        self,
        df: pd.DataFrame,
        ticker: str
    ) -> list[Signal]:
        """
        Generate trading signals for a single ticker.

        Args:
            df: DataFrame with OHLCV data and indicators
            ticker: Stock ticker symbol

        Returns:
            List of Signal objects
        """
        pass

    def calculate_entry_exit_prices(
        self,
        current_price: float,
        direction: SignalDirection,
        atr: float | None = None
    ) -> tuple[float, float, float]:
        """
        Calculate entry, target, and stop prices.

        Args:
            current_price: Current stock price
            direction: BUY or SELL
            atr: Average True Range for volatility-adjusted stops (optional)

        Returns:
            Tuple of (entry_price, target_price, stop_price)
        """
        entry_price = current_price

        if direction == SignalDirection.BUY:
            # For buys: target above, stop below
            target_price = entry_price * (1 + self.take_profit_pct / 100)
            stop_price = entry_price * (1 - self.stop_loss_pct / 100)
        else:
            # For sells/shorts: target below, stop above
            target_price = entry_price * (1 - self.take_profit_pct / 100)
            stop_price = entry_price * (1 + self.stop_loss_pct / 100)

        return entry_price, target_price, stop_price

    def calculate_confidence(
        self,
        base_confidence: float,
        factors: dict[str, float]
    ) -> float:
        """
        Calculate final confidence score with adjustments.

        Args:
            base_confidence: Starting confidence (0-100)
            factors: Dictionary of adjustment factors (multipliers)

        Returns:
            Adjusted confidence score (0-100)
        """
        confidence = base_confidence

        for factor_name, factor_value in factors.items():
            confidence *= factor_value

        # Clamp to 0-100
        return max(0, min(100, confidence))

    @staticmethod
    def calculate_rsi(prices: pd.Series, period: int = 14) -> pd.Series:
        """Calculate Relative Strength Index."""
        delta = prices.diff()
        gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()

        rs = gain / loss.replace(0, np.nan)
        rsi = 100 - (100 / (1 + rs))
        return rsi

    @staticmethod
    def calculate_macd(
        prices: pd.Series,
        fast: int = 12,
        slow: int = 26,
        signal: int = 9
    ) -> tuple[pd.Series, pd.Series, pd.Series]:
        """Calculate MACD, Signal line, and Histogram."""
        ema_fast = prices.ewm(span=fast, adjust=False).mean()
        ema_slow = prices.ewm(span=slow, adjust=False).mean()
        macd = ema_fast - ema_slow
        signal_line = macd.ewm(span=signal, adjust=False).mean()
        histogram = macd - signal_line
        return macd, signal_line, histogram

    @staticmethod
    def calculate_bollinger_bands(
        prices: pd.Series,
        period: int = 20,
        std_dev: float = 2.0
    ) -> tuple[pd.Series, pd.Series, pd.Series]:
        """Calculate Bollinger Bands (middle, upper, lower)."""
        middle = prices.rolling(window=period).mean()
        std = prices.rolling(window=period).std()
        upper = middle + (std * std_dev)
        lower = middle - (std * std_dev)
        return middle, upper, lower

    @staticmethod
    def calculate_atr(
        high: pd.Series,
        low: pd.Series,
        close: pd.Series,
        period: int = 14
    ) -> pd.Series:
        """Calculate Average True Range."""
        tr1 = high - low
        tr2 = abs(high - close.shift())
        tr3 = abs(low - close.shift())
        tr = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)
        atr = tr.rolling(window=period).mean()
        return atr

    @staticmethod
    def calculate_sma(prices: pd.Series, period: int) -> pd.Series:
        """Calculate Simple Moving Average."""
        return prices.rolling(window=period).mean()

    @staticmethod
    def calculate_ema(prices: pd.Series, period: int) -> pd.Series:
        """Calculate Exponential Moving Average."""
        return prices.ewm(span=period, adjust=False).mean()

    @staticmethod
    def calculate_volume_ratio(volume: pd.Series, period: int = 20) -> pd.Series:
        """Calculate volume relative to moving average."""
        avg_volume = volume.rolling(window=period).mean()
        return volume / avg_volume

    def validate_signal(self, signal: Signal) -> bool:
        """
        Validate a signal meets minimum requirements.

        Args:
            signal: Signal to validate

        Returns:
            True if signal is valid
        """
        if signal.confidence < self.min_confidence:
            return False

        if signal.risk_reward_ratio < 1.0:
            return False

        if signal.entry_price <= 0:
            return False

        return True
